"""CylanceOPTICS Refract Package TemplateUse this file as a template to create custom codeto be executed by the CylanceOPTICS endpoint.Most of your custom code will likely be in the'execute' method of the CyInterface class."""# Imports# We must add the IronPython standard library in order to# import python standard modules like 'os' and 'platform'import clrclr.AddReference('IronPython.StdLib')import sysimport osimport platform# Imports C# librariesclr.AddReference('System.Core')from System.Dynamic import ExpandoObject# Custom Imports - Place any other modules to import below this lineclass CyInterface:    """A simple interface class"""    def __init__(self):        """        Add initialization code here for the interface (likely very little)        """        # This prints the name of the of the function in the log        print sys._getframe().f_code.co_name        self.package_output_directory = '.'  # output folder, to be populated in the initialize function    def __del__(self):        """        Add code to be executed when the instance is destroyed (also known as a destructor)        """        print sys._getframe().f_code.co_name    def initialize(self, param):        print sys._getframe().f_code.co_name        # param.print_message decides whether to print to the log or not        if 'print_message' in param:            print '  print_message: ', param.print_message        else:            print 'initialize() does not have print_message'        # Cache various parameters and paths as variables for later use.        # If 'out' is passed as a command line argument, store it as a variable        if "out" in param:            self.package_output_directory = param.out        # The 'self.package_source_directory' gets the path that this script is running from.        # This is useful for referencing other files that may be present in the directory        # whether it is another application to run or a config file to read from.        # To get the current 'output' directory to include files with a Packages results        # use the 'self.package_output_directory' variable        self.package_source_directory = os.path.dirname(os.path.realpath(__file__))        eo = ExpandoObject()  # prepare return value        eo.status = 0  # success        print "Initialization complete."        return eo    def execute(self):        """        This is where most of your custom code should live.        Note: you can use the 'self.package_output_directory' and 'self.package_source_directory' variables        to reference the paths where a package is outputting to or executing from.        """        print sys._getframe().f_code.co_name        eo = ExpandoObject()  # prepare return value        # Start of package code        try:            # print("This is where your package code goes. You can include calls to other "            #      "python files, as well as other files or applications included in the package."            #      "Place any files you want included with the results in self.package_output_directory.")            if (param.ip != None):                try:                    ip = ipaddress.ip_address(param.ip)                    ip_str = str(ip) + "/32"                except Exception as e:                     print("not a valid ip address: {}".format( e.message))            elif (param.net != None):                try:                    ip = ipaddress.ip_network(param.ip)                    ip_str = str(ip)                except Exception as e:                    print "not a vaid network: {}".format( e.message)            # elif (param.url != None):                        # default direction is in, unless set specifically to out                if (param.dir != "out"):                param.dir = "in"            cmd = "netsh advfirewall firewall add rule name="Cylance IP Block" dir=" + param.dir + " interface=any action=block remoteip=" + ip_str            os.system(cmd)            eo.status = 0  # set the return code of the package either manually or as a result of how things went        except Exception as e:            eo.status = -1  # fail            print("Excecution of package failed with error: {}".format( e.message))        # End of package code        print "Package execution completed."        return eo# End of interface API# This is the 'runner' of the package# It is used to get the location of the output directory and# setup the interface. Consider this the "Main" function.# This is also where you can check for and parse additional command line args.def run_test(argv):    import os    print sys._getframe().f_code.co_name    # Imports C# libraries    import clr    from System.Dynamic import ExpandoObject    clr.AddReference('System.Core')    interface = CyInterface()    param = ExpandoObject()    param.print_message = 1  # set print message to True so outputs are in log    # get the output folder from the arguments    # this is also where you would look for other custom arguments    # (by searching for the argument name, incrementing i, and then grabbing that value)    i = 0    for arg in argv:        print 'arg: ', arg        i = i + 1        if arg == "-out":            param.out = argv[i]        elif arg == "-ip":            param.ip = argv[i]        elif arg == "-net":            param.net = argv[i]            elif arg == "-url":            param.url = argv[i]        elif arg == "-dir":            param.dir = argv[i]    print "param.out: ", param.out    print "param.ip: ", param.ip    print "param.net: ", param.net    print "param.url", param.url    print "param.dir", param.dir    # call interface's initialize    result = interface.initialize(param)    # call interface's Excute    result = interface.execute()    # call interface's delete    del interfaceif __name__ == "__main__":    run_test(sys.argv)